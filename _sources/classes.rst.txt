Classes
=======


Data classes
------------
While :doc:`typehinting <typehinting>` is flexible enough to create your own specifications
of, for example, a dataclass, it is easier to use ``pydantic`` for typical cases like have
a dataclass. read more in the `pydantic docs <https://pydantic-docs.helpmanual.io/usage/dataclasses/>`_ about
data classes.

.. code-block:: python

    from datetime import datetime
    from pydantic.dataclasses import dataclass


    @dataclass
    class User:
        id: int
        name: str = 'John Doe'
        signup_ts: datetime = None

Pydantic is great for validation of settings and inputdata, and for sharing requirements between machines. 
The code above checks if the data loaded actually is an integer, string etc etc.
It automatically implements coversion and validation, so:

.. code-block:: python

    >>> User(id='123')

Will transform the id to an integer, and fail if the input is not compatible. 
The decorator also implements dunder methods like: ``__init__``, ``__repr__`` (how it is printed), ``__eq__`` (how it is used with operators like ``==``) etc.
You can read more about the comparison between native (3.7) dataclasses, attrs and pydantic in this `blog <https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html>`_


Base settings
-------------
A slightly different situation is where you have all sorts of settings for your project.
Typically, you will want to specify things like:

- a data directory 
- certain default options for functions
- specific filenames to be loaded
- column names

A first rule-of-thumb is to never hardcode things like this. So, never do 

.. code-block:: python

    def load_data():
        data = pd.read_csv("../../data/file.csv")
        ...

But, instead, go for:

.. code-block:: python

    def load_data(
        data_dir: Path, 
        filename: Path = Path("file.csv")
     ) -> pd.DataFrame:
        filepath = data_dir / filename
        data = pd.read_csv(filepath)
        ...

This way, it is very easy if you want to change the location of data, filename, etc etc.

However, this can still cause problems. It might be the case that you end up with all sorts
of settings, spread over multiple notebooks. Changing urls, filenames etc will then turn
into an excercise that will require you to walk trough every notebook, and to check every single cell. 
That might be ok if you made the notebooks yourself, but you will curse a lot if you get 
an unstructured set of notebooks from someone else that is no longer around to explain the details.

So, a good practice is; in addition to never hardcoding settings, gather all you settings
in one place. 

So, you create a file called settings.py, that looks like this:

.. code-block:: python

    from pydantic import BaseSettings
    from pathlib import Path
    from typing import List


    class Settings(BaseSettings):
        data_dir: Path = Path("../data/")
        target: str = "MonthlySales"
        data_file: Path = Path("file.csv")
        hierarchy: List[str] : ["veggies", "paprika"]
        horizon: int = 4
    
    settings = Settings()

In your notebook, you can now import the settings like this:

.. code-block:: python

    from src.settings import settings

Note that you have a few advantages at once, that are also improvements upon saving settings
in a ``.json`` or ``.yaml`` file.

1. You can use typehinting. This will be used by your :doc:`linters <linting>` to check for consistency.
2. You can load python object. Sure, you will find a way to load a list of floats from ``.json``. But what about a ``Path``? Or a ``StandardScaler`` from sklearn? You could still create workaround with ``eval``, but ``BaseSettings`` is easier.
3. For free, you get functions like ``.dict()`` or ``.json`` to create exports
4. pydantic will integrate with ``mypy``, VS code, ``hypothesis`` etc ec.

Coming back to our example, you would now get:

.. code-block:: python

    data = load_data(
        data_dir = settings.data_dir,
        filename = settings.data_file
    )

You can find `the documentation here <https://pydantic-docs.helpmanual.io/usage/settings/>`_. 

Abstract Classes
----------------
Base python introduced abstract base classes with `PEP 3119 <https://www.python.org/dev/peps/pep-3119/>`_.

A pretty nice introduction into the matter is `this blog <https://blog.teclado.com/python-abc-abstract-base-classes/>`_ from which the following examples are copied.

.. code-block:: python

    class Lion:
    def give_food(self):
        print("Feeding a lion with raw meat!")

    class Panda:
        def feed_animal(self):
            print("Feeding a panda with some tasty bamboo!")

    class Snake:
        def feed_snake(self):
            print("Feeding a snake with mice!")

    leo = Lion()
    po = Panda()
    sam = Snake()

This could be code that evolved over time. However, if you would at some point want
to automate the feeding of the animals, you might want to do something like this:

.. code-block:: python

    zoo = [leo, po, sam] # Could be many more animals there!

    for animal in zoo:
        animal.feed() # This will throw an AttributeError!

so, in order to avoid this, you could do this:

.. code-block:: python

    from abc import ABC, abstractmethod

    class Animal(ABC): # Inherit from ABC(Abstract base class)
        @abstractmethod  # Decorator to define an abstract method
        def feed(self):
            pass

    class Lion(Animal): #this inheriting will make sure
        def feed(self): # you get an TypeError here if you dont implement .feed()!
            print("Feeding a lion with raw meat!") 
