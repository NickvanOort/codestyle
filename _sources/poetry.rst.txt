Poetry
======

Motivation
----------

Using python on multiple architectures (OS x, linux, windows) over a long enough period
in time for libraries to update will expose everyone at some point to the hellish experience
of trying to recreate the exact environment.

The main goal is: we want repeatable builds, across OS, without the need to manage transitive dependencies.

There are more libraries that can do this: ``pipenv``, ``pip-tools``, ``conda``.
However, ``poetry`` is simple and elegant to use, an active project, and works with a very clean ``pyproject.toml`` file.

The `poetry repo <https://github.com/python-poetry/poetry>`_ states its **Why** by saying

.. note::

    Packaging systems and dependency management in Python are rather convoluted and 
    hard to understand for newcomers. Even for seasoned developers it might be cumbersome 
    at times to create all files needed in a Python project: 
    ``setup.py``, ``requirements.txt``, ``setup.cfg``, ``MANIFEST.in`` and the
    newly added ``Pipfile``.

    So I wanted a tool that would limit everything to a single configuration file 
    to do: dependency management, packaging and publishing.

Some examples from my own experience:
If you use ``conda`` or ``pip``, installing a library will install many dependencies.
If you ever want to change something because of conflicting dependencies, it is not 
straightforward to figure out what you installed actively and what was installed as a dependency.
``poetry``, on the other hand, makes this very clear and easy to manage.

``conda`` will even add suffixes speciifc to your OS to the environment export file. There
are trick to avoid that, but it is far from simple.

In addition to that, there is stuff that you will only use while developing (e.g. linters, jupyter notebook) that does no
need to be installed in production. ``poetry`` makes separating dependencies very simple.

Setup with VS code, pyenv and poetry
------------------------------------
A complete run through of a setup with VS code, ``pyenv`` and ``poetry`` is shown in 
this `youtube video <https://www.youtube.com/watch?v=547Jr26duHQ>`_

Pyenv
-----
I personally like to combine ``poetry`` with ``pyenv``. You will still need to have a python
version, and switching versions with ``pyenv`` is very easy. Also, I avoid reinstalling 
python every time I make a new project; typically I will develop with ``3.8.12``, so
having that installed just once is good. It could be done with e.g. conda, but that will
give me an environment manager inside an environment manager, which feels too convoluted.

Installing ``pyenv`` can be done by following the instructions in the `repo <https://github.com/pyenv/pyenv>`_
This works smooth inside `WSL2 <https://docs.microsoft.com/en-us/windows/wsl/install>`_ on Windows, or OS X / Linux.

However, how you manage your python version is not essential for using ``poetry``.

Poetry
------

Note, that if you install python as ``python`` instead of ``python3``, you will need
to change the installation of ``poetry`` to::

    curl -sSL https://install.python-poetry.org | python -

because the poetry documentation puts a ``3`` behind ``pyhton``.


Basic usage can be summed up with

.. code-block:: bash

    $ cd pre-existing-project
    $ poetry init

This will run you through an interactive guide.
After this, you will have a ``pyproject.toml`` file that is human readable,
and a computer readable ``poetry.lock`` file that has a complete list of all resolved dependencies.

Adding dependencies later on can be done with:

.. code-block:: bash

    $ poetry add torch
    $ poetry add black --dev

The ``black`` library will be installed under dev-dependencies, 
and could be ommitted with ``poetry install --no-dev``

Reproducing the environment is as simple as ``poetry install``. All dependencies are installed in parallel, so it is faster too than ``conda``.
